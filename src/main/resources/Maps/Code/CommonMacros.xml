<?xml version="1.1" encoding="UTF-8"?>

<!--
 * See the NOTICE file distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
-->

<xwikidoc version="1.3" reference="Maps.Code.CommonMacros" locale="">
  <web>Maps.Code</web>
  <name>CommonMacros</name>
  <language/>
  <defaultLanguage/>
  <translation>0</translation>
  <creator>xwiki:XWiki.Admin</creator>
  <parent>Maps.Code.Leaflet</parent>
  <author>xwiki:XWiki.Admin</author>
  <contentAuthor>xwiki:XWiki.Admin</contentAuthor>
  <version>1.1</version>
  <title>CommonMacros</title>
  <comment/>
  <minorEdit>false</minorEdit>
  <syntaxId>xwiki/2.1</syntaxId>
  <hidden>true</hidden>
  <content>{{velocity output="false"}}
#set ($solrConfig = {
  'filterQuery': [
    'type:DOCUMENT', 'class:Maps.Code.PointClass'
  ],
  'facetFields': [
    'space', 'property.XWiki.TagClass.tags_string', 'property.Maps.MapTesting.Museums.Code.MuseumClass.country_string'
  ]
})
{{/velocity}}

{{include reference="Main.SolrSearchConfig" /}}

{{include reference="Main.SolrSearchMacros" /}}

{{velocity output="false"}}
## Get HTML from XWiki/2.1 syntax
#macro (getHtml $xwiki)
  #set ($xdom = $services.rendering.parse($xwiki, "xwiki/2.1"))
  $services.rendering.render($xdom, "xhtml/1.0")
#end
## Handle the response of solr query
#macro (handleSolrResponse $searchResponse)
  #set ($mapDataArr = [])
  #foreach ($response in $searchResponse.getResults())
    ## Check if the page contains a Point object
    #if ("$!response.get('property.Maps.Code.PointClass.location_string')" != '')
      #set ($responseData = {})
      ## Get document title
      #set ($title = $response.get('title_'))
      ## Get document content as html
      #set ($popupContent = "#getHtml($response.get('doccontentraw_'))")
      ## Get the location
      #set ($location = $response.get('property.Maps.Code.PointClass.location_string')[0])
      ## Set the collected information
      #set ($discard = $responseData.put('title', $title))
      #set ($discard = $responseData.put('location', $location))
      #set ($discard = $responseData.put('popupContent', $popupContent))
      ## Get attachment URL for marker icon if attachment available
      #set ($targetDoc = $xwiki.getDocument($response.get('fullname')))
      #set ($firstAttachment = $targetDoc.getAttachmentList())
      #if (!$firstAttachment.isEmpty())
        #set ($attachmentURL = $targetDoc.getAttachmentURL($firstAttachment.get(0).getFilename()))
        #set ($discard = $responseData.put('markerIcon', $attachmentURL))
      #end
      ## Add the collected data into array
      #set ($discard = $mapDataArr.add($responseData))
    #end
  #end
  $jsontool.serialize($mapDataArr)
#end
## Run the solr query and get data for map in json
#macro (handleMapQuery $queryStatement)
  #set ($query = $services.query.createQuery($queryStatement, 'solr'))
  #set ($discard = $query.bindValue('fq', '{!q.op=AND} type:DOCUMENT'))
  #set ($searchResponse = $query.execute()[0])
  #set ($mapData = "#handleSolrResponse(${searchResponse})")
  $mapData
#end

##
## The macros below belong to Main.SolrSearchMacros and have been altered to support map queries
##

#macro (getMapResults)
  ## $queryStatement is set before using the macro
  #if ($text != '')
    #set ($queryString = "($!{queryStatement}) AND ($!{text})")
  #else
    #set ($queryString = "($!{queryStatement})")
  #end
  ##
  ## Create the query and set the query string.
  #set ($query = $services.query.createQuery($queryString, 'solr'))
  ##
  ## Set query parameters.
  #set ($discard = $query.setLimit($rows))
  #set ($discard = $query.setOffset($start))
  #set ($discard = $query.bindValue('sort', "${sort} ${sortOrder}"))
  #set ($discard = $query.bindValue('tie', $solrConfig.tieBreaker))
  #set ($discard = $query.bindValue('mm', $solrConfig.minShouldMatch))
  #set ($discard = $query.bindValue('fq', 'type:DOCUMENT AND (object:Maps.Code.PointClass)'))
  #setQueryFields($query)
  #setPhraseFields($query)
  #setFacetFields($query)
  #setFilterQuery($query)
  #setHighlightQuery($query)
  #if ($debug)
    #set ($discard = $query.bindValue('debugQuery', 'on'))
  #end
  ##
  ## Execute the query.
  #set ($searchResponse = $query.execute()[0])
#end
#macro (displayMapUI)
  #set($void = $services.progress.startStep('#displaySearchUI'))
  #set($void = $services.progress.pushLevel())
  #set ($discard = $xwiki.ssx.use('Main.SolrSearch'))
  #set ($discard = $xwiki.jsx.use('Main.SolrSearch'))
  ## Disable the document extra data: comments, attachments, history...
  #set ($displayDocExtra = false)
  #processRequestParameters()
  (% class="search-ui" %)(((
    #if ($xcontext.action == 'get')
      {{html clean="false"}}
      ## The search UI is updated dynamically through AJAX and we need to pull the skin extensions.
      ## We put the skin extension imports inside a &lt;noscript&gt; element to prevent jQuery from fetching the JavaScript
      ## files automatically (we want to fetch only the new JavaScript files).
      &lt;noscript class="hidden skin-extension-imports"&gt;#skinExtensionHooks&lt;/noscript&gt;
      {{/html}}

    #end
    #displaySearchForm()
    #getMapResults()
    #if ($debug)
      #displaySearchDebugInfo()
    #end
    (% class="search-results-container row" %)(((
      #if ($facetEnabled)
        (% class="col-xs-12 col-sm-4 col-sm-push-8 col-md-3 col-md-push-9" %)(((
          #displaySearchFacets($searchResponse)
        )))
      #end
      (% class="search-results-left col-xs-12#if ($facetEnabled) col-sm-8 col-sm-pull-4 col-md-9 col-md-pull-3#end" %)
      (((
        (% class="search-results" %)(((
          #set ($mapData = "#handleSolrResponse(${searchResponse})")
          ## $mapId, $mapObjJSON are already set before using this macro
          (% class="map-container" id="map-${mapId}" data-options='${mapObjJSON}' data-mapdata='${mapData}' style="width: 100%; height: 400px;" %)((()))
        )))
      )))
    )))
  )))
  #set($void = $services.progress.popLevel())
  #set($void = $services.progress.endStep())
#end

##
## Facet macros
##

#macro (displaySearchFacetBody $facetField)
  &lt;div class="search-facet-body"&gt;
    #set ($facetDisplayer = $solrConfig.facetDisplayers.get($facetField.name))
    #if (!$facetDisplayer &amp;&amp; $facetField.name.startsWith('property.'))
      ## Choose a facet displayer based on the property type.
      #getXClassProperty($facetField.name $property)
      ## We rely on configuration instead of using a naming convention like "Main.Solr${property.classType}Facet"
      ## because most of the property types don't need a custom facet displayer.
      #set ($facetDisplayer = $solrConfig.facetDisplayersByPropertyType.get($property.classType))
    #end
    #displaySearchFacetValues($facetValues)
    ## Below code does not render the facets properly
    #*
    #if ($facetDisplayer)
      #set ($facetDisplayer = $xwiki.getDocument($facetDisplayer))
      #if ("$!facetDisplayer.content" != '')
        $!facetDisplayer.getRenderedContent(false)
      #else
        #displaySearchFacetValues($facetValues)
      #end
    #else
      #displaySearchFacetValues($facetValues)
    #end
    *#
  &lt;/div&gt;
#end
{{/velocity}}</content>
</xwikidoc>
